#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include <shadow.h>
#include <unistd.h>
#include <crypt.h>
#include "tcpserver.h"

/*
static void discovery_sendTo(void *arg, uint8_t code, uint8_t *data, int size)
{
	clients *client = (clients *)arg;
	if(client == NULL) return;

	uint8_t pkt_temp[32] = {0};
	uint8_t temp[200] = {0};
	uint8_t *enc = pkt_temp;
	
	packet pkt = {0};
	pkt.id = 0;
	pkt.command = CMD_RADIONETWORK;
	pkt.ack = ACK_NOP;
	pkt.data = pkt_temp;

	*enc++= 0x3;
	enc = packet_encodeByte(enc, code);
	
	if(size > 0){
		memcpy(enc, data, size);
		enc+=size;
	}
	
	pkt.length = enc - pkt_temp;

	int len = packet_readBuffer(&pkt, temp);
	bufferevent_write(client->buf_ev, temp, len);
}

static void onPacketRead(clients *client, packet *pkt)
{
	
}
*/

TcpServer::TcpServer(uint16_t port)
:_port(port), boardhandler(NULL), logged(false)
{
	memset(&username, '\0', sizeof(username));
	memset(&password, '\0', sizeof(password));
}

TcpServer::~TcpServer(void)
{
	
}


bool TcpServer::CheckLogin(const char *user, const char *pass)
{
	if(this->logged){
		return (strcmp(user, username) == 0 && strcmp(pass, password) == 0);
	}else{	
#ifdef OS_UBUNTU	
		memcpy(username, "admin", strlen("admin"));
		memcpy(password, "123456", strlen("123456"));
		logged = true;
#else
		struct spwd *spw;
		char key_buf[48];
		char *key=key_buf;
		char salt[12];

		memset(key,'\0',sizeof(key));
		memset(salt,'\0',sizeof(salt));
  
		spw=getspnam(user);
		if(spw==NULL)
		{
			printf("getspnam err\n");
			return false;
		}

		printf("spw->sp_pwdp:%s\n",spw->sp_pwdp);
		memcpy(salt,spw->sp_pwdp,12);
		printf("salt:%s\n",salt);
		key=crypt(pass, salt);
		printf("key:%s\n",key);
		if(!memcmp(key,spw->sp_pwdp, strlen(key))) //login err
		{
			memcpy(username, user, strlen(user));
			memcpy(password, pass, strlen(pass));

			logged = true;
		}
#endif	
	}
	return logged;
}

void TcpServer::OnAccept(Client *client)
{
	clients.push_back(client);
}

void TcpServer::OnDisconnect(Client *client)
{
	clients.remove(client);
}

void TcpServer::onPacketRead(Client *client, Packet *pkt)
{	
	if(!client->IsLogin() && pkt->GetCommand() != CMD_LOGIN){
		pkt->ResetToSend();
		pkt->EncodeBoolean(false);
		pkt->EncodeString("not login");
		pkt->SetCommand(CMD_LOGIN);
		pkt->AutoAck();
		pkt->EncodeBuffer();

		client->Send(pkt->getBuffer(), pkt->getLength());
		return;
	}
	
	switch(pkt->GetCommand())
	{
		case CMD_SERIAL:
		{
	        uint8_t temp[260] = {0};
			uint8_t *enc = temp;
			enc = pkt->toHardware(enc);
			if(boardhandler!=NULL){
				boardhandler->Send(temp, enc - temp);
			}
			break;
		}
		case CMD_DEVICE_INFO:
		{
			uint8_t *enc;
			uint8_t *version;
			struct timeval tv;
			gettimeofday(&tv,NULL);

            if(boardhandler!=NULL){
			   version = boardhandler->GetVersion();
			}

			pkt->ResetToSend();
			pkt->EncodeString((const char *)version);
			pkt->EncodeString(VERSION_HARDWARE);
			pkt->EncodeInt32(tv.tv_sec);
			pkt->SetCommand(pkt->GetCommand());
			pkt->AutoAck();
		    pkt->EncodeBuffer();
			            
			client->Send(pkt->getBuffer(), pkt->getLength());
			break;
		}
		case CMD_SCHEDULE_TASK:
		{
			break;
		}
		case CMD_TRIGGER:
		{
			break;
		}
		case CMD_LOGIN:
		{
			char temp_user[50] = {0};
			char temp_pass[50] = {0};
			str_st username = {0};
			str_st password = {0};

			pkt->DecodeString(&username);
			pkt->DecodeString(&password);

			memcpy(temp_user, username.str, username.len);
			memcpy(temp_pass, password.str, password.len);

			pkt->ResetToSend();
			
			if(CheckLogin(temp_user, temp_pass)){
				client->SetLogin(true);
				pkt->EncodeBoolean(true);
		        pkt->EncodeString("logged");
			}else{ 
				client->SetLogin(false);
				pkt->EncodeBoolean(false);
		        pkt->EncodeString("username or password error");
			}

			pkt->AutoAck();
		    pkt->EncodeBuffer();
		    client->Send(pkt->getBuffer(), pkt->getLength());
			break;
		}/*
		case CMD_RADIONETWORK:
		{
			uint8_t *enc = pkt->data;
			uint8_t cmd = *enc++;
			RADIO_NETWORK *radio = client->serv->radio;

			switch(cmd)
			{
				case 0x1:
				{					
					enc = packet_decodeBoolean(enc, &radio->state);
					enc = packet_decodeByte(enc, &radio->role);
					enc = packet_decodeByte(enc, &radio->addr);
					enc = packet_decodeByte(enc, &radio->channel);

					enc = pkt->data+1;
					if(radionetwork_config(client->serv->task, radio)){
					    enc = packet_encodeBoolean(enc, 0x1);
					}else{
					    enc = packet_encodeBoolean(enc, 0x0);
					}
					pkt->length = enc - pkt->data;
		            pkt->ack = pkt->ack == ACK_ASK ? ACK_REPLY : ACK_NOP;	
		            int size = packet_readBuffer(pkt, temp);
		            bufferevent_write(client->buf_ev, temp, size);
					break;
				}
				case 0x2:
				{
					enc = packet_encodeBoolean(enc, radio->state);
					enc = packet_encodeByte(enc, radio->role);
					enc = packet_encodeByte(enc, radio->addr);
					enc = packet_encodeByte(enc, radio->channel);
					pkt->length = enc - pkt->data;
		            pkt->ack = pkt->ack == ACK_ASK ? ACK_REPLY : ACK_NOP;	
		            int size = packet_readBuffer(pkt, temp);
		            bufferevent_write(client->buf_ev, temp, size);
					break;
				}
				case 0x3:
				{
					enc = packet_decodeByte(enc, &radio->dis_addr);
					enc = packet_decodeByte(enc, &radio->dis_channel);
					
					enc = pkt->data+1;
					uint8_t state = radionetwork_discovery(radio, discovery_sendTo, client);
					enc = packet_encodeByte(enc, state);
					
                    pkt->length = enc - pkt->data;
		            pkt->ack = pkt->ack == ACK_ASK ? ACK_REPLY : ACK_NOP;	
		            int size = packet_readBuffer(pkt, temp);
		            bufferevent_write(client->buf_ev, temp, size);
					
					break;
				}
				case 0x4:
				{
					uint8_t opt = *enc++;
				    uint16_t id = 0;
					enc = packet_decodeInt16(enc, &id);

					switch(opt){
						case 0:
						{
							uint16_t level = 0;
					        enc = packet_decodeInt16(enc, &level);
							enc = radionetwork_read_config(enc, radio, id, level);							
							break;
						}
						case 0xAA:
						{
							radionetwork_add_radio(radio, enc, pkt->length - (enc - pkt->data));
							break;
						}
						case 0xEE:
						{
							uint8_t ret = radionetwork_edit_radio(radio, id, enc, pkt->length - (enc - pkt->data));
							enc = packet_encodeBoolean(enc, ret);
							break;
						}
						case 0xDD:
						{
							uint8_t ret = radionetwork_delete_radio(radio, id);
							enc = packet_encodeBoolean(enc, ret);
							break;
						}
					}
					
					pkt->length = enc - pkt->data;
		            pkt->ack = pkt->ack == ACK_ASK ? ACK_REPLY : ACK_NOP;	
		            int size = packet_readBuffer(pkt, temp);
		            bufferevent_write(client->buf_ev, temp, size);
					break;
				}
				case 0x5:
				{
					uint16_t id  = 0;
					uint16_t level = 0;
 					enc = packet_decodeInt16(enc, &id);
					enc = packet_decodeInt16(enc, &level);

					if(id > 0){
					    uint8_t state = radionetwork_child_discovery(radio, discovery_sendTo, client, id, level);
						enc = packet_encodeByte(enc, state);
					
                        pkt->length = enc - pkt->data;
		                pkt->ack = pkt->ack == ACK_ASK ? ACK_REPLY : ACK_NOP;	
		                int size = packet_readBuffer(pkt, temp);
		                bufferevent_write(client->buf_ev, temp, size);
					}
					break;
				}
				case 0xdd:
				{
					
					break;
				}
			}
			
			break;
		}*/
	    case CMD_SYSTEM:
		{
			uint8_t type = pkt->ReadByte();
			if(type == DATA_KEYVALUE){
			    char temp_key[50] = {0};
			    char temp_val[50] = {0};
				str_st key = {0};
				str_st val = {0};

				pkt->DecodeString(&key);
				pkt->DecodeString(&val);
				
				
                memcpy(temp_key, key.str, key.len);
			    memcpy(temp_val, val.str, val.len);
				
				if(strcmp(temp_key, "system")==0){					
					if(strcmp(temp_val, "reboot")==0){
			             pkt->ResetToSend();
				         pkt->EncodeBoolean(true);
		                 pkt->EncodeString("reboot");						
			             system("reboot");
					}else if(strcmp(temp_val, "update")==0){
						 type = pkt->ReadByte();
						 if(type == DATA_KEYVALUE){
				             pkt->DecodeString(&key);
				             pkt->DecodeString(&val);
							 memcpy(temp_key, key.str, key.len);
							 memcpy(temp_val, val.str, val.len);
							 if(strcmp(temp_key, "url")==0){
								 //do something,if needed to use remote url
							 }
						 }
						
			             pkt->ResetToSend();
				         pkt->EncodeBoolean(true);
		                 pkt->EncodeString("update");
								
			             system("/root/upgsbox.sh");	
						
					}else if(strcmp(temp_val, "update-firmware")==0){
						 type = pkt->ReadByte();
						 if(type == DATA_KEYVALUE){
				             pkt->DecodeString(&key);
				             pkt->DecodeString(&val);
							 memcpy(temp_key, key.str, key.len);
							 memcpy(temp_val, val.str, val.len);
							 if(strcmp(temp_key, "url")==0){
								 //do something,if needed to use remote url
							 }
						 }
						
			             pkt->ResetToSend();
				         pkt->EncodeBoolean(true);
		                 pkt->EncodeString("update-firmware");
						
						 system("/root/upfirmware.sh");	
					}	
								        
			        pkt->AutoAck();
		            pkt->EncodeBuffer();
		            client->Send(pkt->getBuffer(), pkt->getLength());
				}
			}
			break;
		}
	}

	if(pkt->GetAck() == ACK_ASK){
	    pkt->ResetToSend();
		pkt->AutoAck();
		pkt->EncodeBuffer();
		client->Send(pkt->getBuffer(), pkt->getLength());
	}
}

void TcpServer::OnDataRead(Client *client,uint8_t *data, int size)
{		
	Packet pkt(data, size);
    while(pkt.Decode()){
		onPacketRead(client, &pkt);
	}
}

void TcpServer::Send(serial_packet *ser_pkt)
{	
	Packet pkt;
	pkt.ResetToSend();
	pkt.SetCommand(CMD_SERIAL);
	pkt.SetAck(ACK_NOP);
	pkt.WriteBuffer(ser_pkt->data, ser_pkt->read_size);
	pkt.EncodeBuffer();
	
	std::list<Client *>::const_iterator it = clients.begin();
	for (; it != clients.end(); it++)
	{
		(*it)->Send(pkt.getBuffer(), pkt.getLength());
	}
}
